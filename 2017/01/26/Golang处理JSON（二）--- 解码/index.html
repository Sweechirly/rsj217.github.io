<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="golang,mysql," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="golang编码json还比较简单，而解析json则非常蛋疼。不像Python一句json.loads就能搞定。之前项目开发中，为了兼容不同客户端的需求，请求的content-type可以是json，也可以是www-x-urlencode。然后某天前端希望某个后端服务提供json的处理，而当时后端使用java实现了www-x-urlencode的请求，对于突然希望提供json处理产生了极大的情绪。">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang处理JSON（二）--- 解码">
<meta property="og:url" content="http://rsj217.github.com/2017/01/26/Golang处理JSON（二）--- 解码/index.html">
<meta property="og:site_name">
<meta property="og:description" content="golang编码json还比较简单，而解析json则非常蛋疼。不像Python一句json.loads就能搞定。之前项目开发中，为了兼容不同客户端的需求，请求的content-type可以是json，也可以是www-x-urlencode。然后某天前端希望某个后端服务提供json的处理，而当时后端使用java实现了www-x-urlencode的请求，对于突然希望提供json处理产生了极大的情绪。">
<meta property="og:updated_time" content="2017-04-02T09:11:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Golang处理JSON（二）--- 解码">
<meta name="twitter:description" content="golang编码json还比较简单，而解析json则非常蛋疼。不像Python一句json.loads就能搞定。之前项目开发中，为了兼容不同客户端的需求，请求的content-type可以是json，也可以是www-x-urlencode。然后某天前端希望某个后端服务提供json的处理，而当时后端使用java实现了www-x-urlencode的请求，对于突然希望提供json处理产生了极大的情绪。">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://rsj217.github.com/2017/01/26/Golang处理JSON（二）--- 解码/"/>


  <title> Golang处理JSON（二）--- 解码 |  </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta custom-logo">
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="/logo.png"
             alt=""/>
      </a>
    </div>
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title"></span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">艺术·极客·流氓</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            文章
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-resume-zh">
          <a href="/resume" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            简历
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Golang处理JSON（二）--- 解码
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-01-26T12:31:02+08:00" content="2017-01-26">
              2017-01-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术流/" itemprop="url" rel="index">
                    <span itemprop="name">技术流</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>golang编码json还比较简单，而解析json则非常蛋疼。不像Python一句json.loads就能搞定。之前项目开发中，为了兼容不同客户端的需求，请求的content-type可以是json，也可以是www-x-urlencode。然后某天前端希望某个后端服务提供json的处理，而当时后端使用java实现了www-x-urlencode的请求，对于突然希望提供json处理产生了极大的情绪。当时不太理解，现在看来，对于静态语言解析未知的JSON确实是一项挑战。</p>
<a id="more"></a>
<h3 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h3><p>与编码json的Marshal类似，解析json也提供了Unmarshal方法。对于解析json，也大致分两步，首先定义结构，然后调用Unmarshal方法序列化。我们先从简单的例子开始吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">type Account struct &#123;</div><div class="line">    Email    string  `json:&quot;email&quot;`</div><div class="line">    Password string  `json:&quot;password&quot;`</div><div class="line">    Money    float64 `json:&quot;money&quot;`</div><div class="line">&#125;</div><div class="line"></div><div class="line">var jsonString string = `&#123;</div><div class="line">    &quot;email&quot;:&quot;rsj217@gmail.com&quot;,</div><div class="line">    &quot;password&quot;:&quot;123&quot;,</div><div class="line">    &quot;money&quot;:100.5</div><div class="line">&#125;`</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line"></div><div class="line">    account := Account&#123;&#125;</div><div class="line"></div><div class="line">    err := json.Unmarshal([]byte(jsonString), &amp;account)</div><div class="line">    if err != nil&#123;</div><div class="line">        log.Fatalln(err)</div><div class="line">    &#125;</div><div class="line">    fmt.Printf(&quot;%+v\n&quot;, account)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Unmarshal接受一个byte数组和空接口指针的参数。和sql中读取数据类似，先定义一个数据实例，然后传其指针地址。</p>
<p>与编码类似，golang会将json的数据结构和go的数据结构进行匹配。匹配的原则就是寻找tag的相同的字段，然后查找字段。查询的时候是大小写不敏感的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">type Account struct &#123;</div><div class="line">    Email    string  `json:&quot;email&quot;`</div><div class="line">    PassWord string  </div><div class="line">    Money    float64 `json:&quot;money&quot;`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出<code>{Email:rsj217@gmail.com PassWord:123 Money:100.5}</code>，把 Password的tag去掉，再修改成PassWord，依然可以把json的password匹配到PassWord，但是如果结构的字段是私有的，即使tag符合，也不会被解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">type Account struct &#123;</div><div class="line">    Email    string  `json:&quot;email&quot;`</div><div class="line">    password string  `json:&quot;password&quot;`</div><div class="line">    Money    float64 `json:&quot;money&quot;`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出<code>{Email:rsj217@gmail.com password: Money:100.5}</code>。上面的password并不会被解析赋值json的password，大小写不敏感只是针对公有字段而言。再寻找tag或字段的时候匹配不成功，则会抛弃这个json字段的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">type Account struct &#123;</div><div class="line">    Email    string  `json:&quot;email&quot;`</div><div class="line">    Password string  `json:&quot;password&quot;`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出 <code>{Email:rsj217@gmail.com Password:&quot;123&quot;}</code>， 并不会有money字段被赋值。</p>
<h4 id="string-tag"><a href="#string-tag" class="headerlink" title="string tag"></a>string tag</h4><p>在编码的时候，我们使用tag string，可以把结构定义的数字类型以字串形式编码。同样在解码的时候，只有字串类型的数字，才能被正确解析，或者会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">type Account struct &#123;</div><div class="line">    Email    string  `json:&quot;email&quot;`</div><div class="line">    Password string  `json:&quot;password&quot;`</div><div class="line">    Money    float64 `json:&quot;money,string&quot;`</div><div class="line">&#125;</div><div class="line"></div><div class="line">var jsonString string = `&#123;</div><div class="line">    &quot;email&quot;:&quot;rsj217@gmail.com&quot;,</div><div class="line">    &quot;password&quot;:&quot;123&quot;,</div><div class="line">    &quot;money&quot;:&quot;100.5&quot;</div><div class="line">&#125;`</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line"></div><div class="line">    account := Account&#123;&#125;</div><div class="line"></div><div class="line">    err := json.Unmarshal([]byte(jsonString), &amp;account)</div><div class="line">    if err != nil&#123;</div><div class="line">        log.Fatalln(err)</div><div class="line">    &#125;</div><div class="line">    fmt.Printf(&quot;%+v\n&quot;, account)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出： <code>{Email:rsj217@gmail.com Password:123 Money:100.5}</code>， Money是float64类型。</p>
<p>如果json的money是<code>100.5</code>， 会得到下面的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2016/12/23 18:12:32 json: invalid use of ,string struct tag, trying to unmarshal unquoted value into float64</div><div class="line">exit status 1</div></pre></td></tr></table></figure>
<h4 id="tag"><a href="#tag" class="headerlink" title="- tag"></a><code>-</code> tag</h4><p>与编码一样，tag的<code>-</code>也不会被解析，但是会初始化其零值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">type Account struct &#123;</div><div class="line">    Email    string  `json:&quot;email&quot;`</div><div class="line">    Password string  `json:&quot;password&quot;`</div><div class="line">    Money    float64 `json:&quot;-&quot;`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<code>{Email:rsj217@gmail.com Password:123 Money:0}</code>。</p>
<p>稍微总结一下，解析json最好的方式就是定义与将要被解析json的结构。有人写了一个小工具<a href="https://mholt.github.io/json-to-go/" target="_blank" rel="external">json-to-go</a>，自动将json格式化成golang的结构。</p>
<h3 id="动态解析"><a href="#动态解析" class="headerlink" title="动态解析"></a>动态解析</h3><p>通常更加json的格式预先定义golang的结构进行解析是最理想的情况。可是实际开发中，理想的情况往往都存在理想的愿望之中，很多json非但格式不确定，有的还可能是动态数据类型。</p>
<p>例如通常登录的时候，往往既可以使用手机号做用户名，也可以使用邮件做用户名，客户端传的json可以是字串，也可以是数字。此时服务端解析就需要技巧了。</p>
<h4 id="Decode"><a href="#Decode" class="headerlink" title="Decode"></a>Decode</h4><p>前面我们使用了简单的方法Unmarshal直接解析json字串，下面我们使用更底层的方法NewDecode和Decode方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">type User struct &#123;</div><div class="line">    UserName string `json:&quot;username&quot;`</div><div class="line">    Password string     `json:&quot;password&quot;`</div><div class="line">&#125;</div><div class="line"></div><div class="line">var jsonString string = `&#123;</div><div class="line">    &quot;username&quot;:&quot;rsj217@gmail.com&quot;,</div><div class="line">    &quot;password&quot;:&quot;123&quot;</div><div class="line">&#125;`</div><div class="line"></div><div class="line">func Decode(r io.Reader)(u *User, err error)  &#123;</div><div class="line">    u = new(User)</div><div class="line">    err = json.NewDecoder(r).Decode(u)</div><div class="line">    if err != nil&#123;</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    return</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    user, err := Decode(strings.NewReader(jsonString))</div><div class="line">    if err !=nil&#123;</div><div class="line">        log.Fatalln(err)</div><div class="line">    &#125;</div><div class="line">    fmt.Printf(&quot;%#v\n&quot;,user)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们定义了一个Decode函数，在这个函数进行json字串的解析。然后调用json的NewDecoder方法构造一个Decode对象，最后使用这个对象的Decode方法赋值给定义好的结构对象。</p>
<blockquote>
<p>对于字串，可是使用strings.NewReader方法，让字串变成一个Stream对象。</p>
</blockquote>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>如果客户端传的username的值是一个数字类型的手机号，那么上面的解析方法将会失败。正如我们之前所介绍的动态类型行为一样，使用空接口可以hold住这样的情景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">type User struct &#123;</div><div class="line">    UserName interface&#123;&#125; `json:&quot;username&quot;`</div><div class="line">    Password string      `json:&quot;password&quot;`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后再运行发送输出为 <code>&amp;main.User{UserName:1.8512341234e+10, Password:&quot;123&quot;}</code>。怎么说，貌似成功了，可是返回的数字是科学计数法，有点奇怪。可以使用golang的断言，然后转换类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">func Decode(r io.Reader) (u *User, err error) &#123;</div><div class="line">    u = new(User)</div><div class="line">    if err = json.NewDecoder(r).Decode(u); err != nil&#123;</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    switch t := u.UserName.(type) &#123;</div><div class="line">    case string:</div><div class="line">        u.UserName = t</div><div class="line">    case float64:</div><div class="line">        u.UserName = int64(t)</div><div class="line">    &#125;</div><div class="line">    return</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    user, err := Decode(strings.NewReader(jsonString))</div><div class="line">    if err != nil &#123;</div><div class="line">        log.Fatalln(err)</div><div class="line">    &#125;</div><div class="line">    fmt.Printf(&quot;%#v\n&quot;, user)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出 <code>&amp;main.User{UserName:18512341234, Password:&quot;123&quot;}</code>。看起来挺好，可是我们的UserName字段始终是一个空接口，使用他的时候，还是需要转换类型，这样情况看来，解析的时候就应该转换好类型，那么用的时候就省心了。</p>
<p>修改定义的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">type User struct &#123;</div><div class="line">    UserName interface&#123;&#125; `json:&quot;username&quot;`</div><div class="line">    Password string      `json:&quot;password&quot;`</div><div class="line"></div><div class="line">    Email string</div><div class="line">    Phone int64</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就能通过 <code>fmt.Println(user.Email + &quot; add me&quot;)</code>使用字段进行操作了。当然也有人认为Email和Phone纯粹多于，因为使用的时候，还是需要再判断当前结构实例是那种情况。</p>
<h4 id="延迟解析"><a href="#延迟解析" class="headerlink" title="延迟解析"></a>延迟解析</h4><p>因为UserName字段，实际上是在使用的时候，才会用到他的具体类型，因此我们可以延迟解析。使用json.RawMessage方式，将json的字串继续以byte数组方式存在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">type User struct &#123;</div><div class="line">    UserName json.RawMessage `json:&quot;username&quot;`</div><div class="line">    Password string      `json:&quot;password&quot;`</div><div class="line"></div><div class="line">    Email string</div><div class="line">    Phone int64</div><div class="line">&#125;</div><div class="line"></div><div class="line">var jsonString string = `&#123;</div><div class="line">    &quot;username&quot;:&quot;18512341234@qq.com&quot;,</div><div class="line">    &quot;password&quot;:&quot;123&quot;</div><div class="line">&#125;`</div><div class="line"></div><div class="line">func Decode(r io.Reader) (u *User, err error) &#123;</div><div class="line">    u = new(User)</div><div class="line">    if err = json.NewDecoder(r).Decode(u); err != nil&#123;</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    var email string</div><div class="line">    if err = json.Unmarshal(u.UserName, &amp;email); err == nil&#123;</div><div class="line">        u.Email = email</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    var phone int64</div><div class="line">    if err = json.Unmarshal(u.UserName, &amp;phone); err == nil&#123;</div><div class="line">        u.Phone = phone</div><div class="line">    &#125;</div><div class="line">    return</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    user, err := Decode(strings.NewReader(jsonString))</div><div class="line">    if err != nil &#123;</div><div class="line">        log.Fatalln(err)</div><div class="line">    &#125;</div><div class="line">    fmt.Printf(&quot;%#v\n&quot;, user)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总体而言，延迟解析和使用空接口的方式类似。需要再次调用Unmarshal方法，对json.RawMessage进行解析。原理和解析到接口的形式类似。</p>
<h3 id="不定字段解析"><a href="#不定字段解析" class="headerlink" title="不定字段解析"></a>不定字段解析</h3><p>对于未知json结构的解析，不同的数据类型可以映射到接口或者使用延迟解析。有时候，会遇到json的数据字段都不一样的情况。例如需要解析下面一个json字串：</p>
<h4 id="接口配合断言"><a href="#接口配合断言" class="headerlink" title="接口配合断言"></a>接口配合断言</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var jsonString string = `&#123;</div><div class="line">        &quot;things&quot;: [</div><div class="line">            &#123;</div><div class="line">                &quot;name&quot;: &quot;Alice&quot;,</div><div class="line">                &quot;age&quot;: 37</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                &quot;city&quot;: &quot;Ipoh&quot;,</div><div class="line">                &quot;country&quot;: &quot;Malaysia&quot;</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                &quot;name&quot;: &quot;Bob&quot;,</div><div class="line">                &quot;age&quot;: 36</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                &quot;city&quot;: &quot;Northampton&quot;,</div><div class="line">                &quot;country&quot;: &quot;England&quot;</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;`</div></pre></td></tr></table></figure>
<p>json字串的是一个对象，其中一个key things的值是一个数组，这个数组的每一个item都未必一样，大致是两种数据结构，可以抽象为person和place。即，定义下面的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">type Person struct &#123;</div><div class="line">    Name string `json:&quot;name&quot;`</div><div class="line">    Age  int    `json:&quot;age&quot;`</div><div class="line">&#125;</div><div class="line"></div><div class="line">type Place struct &#123;</div><div class="line">    City    string `json:&quot;city&quot;`</div><div class="line">    Country string `json:&quot;country&quot;`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们Unmarshal json字串到一个map结构，然后迭代item并使用type断言的方式解析数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">func decode(jsonStr []byte) (persons []Person, places []Place) &#123;</div><div class="line">    var data map[string][]map[string]interface&#123;&#125;</div><div class="line">    err := json.Unmarshal(jsonStr, &amp;data)</div><div class="line">    if err != nil &#123;</div><div class="line">        fmt.Println(err)</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for i := range data[&quot;things&quot;] &#123;</div><div class="line">        item := data[&quot;things&quot;][i]</div><div class="line">        if item[&quot;name&quot;] != nil &#123;</div><div class="line">            persons = addPerson(persons, item)</div><div class="line">        &#125; else &#123;</div><div class="line">            places = addPlace(places, item)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    return</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>迭代的时候会判断item是否是person还是place，然后调用对应的解析方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">func addPerson(persons []Person, item map[string]interface&#123;&#125;) []Person &#123;</div><div class="line">    name := item[&quot;name&quot;].(string)</div><div class="line">    age := item[&quot;age&quot;].(float64)</div><div class="line">    person := Person&#123;name, int(age)&#125;</div><div class="line">    persons = append(persons, person)</div><div class="line">    return persons</div><div class="line">&#125;</div><div class="line"></div><div class="line">func addPlace(places []Place, item map[string]interface&#123;&#125;)([]Place)&#123;</div><div class="line">    city := item[&quot;city&quot;].(string)</div><div class="line">    country := item[&quot;country&quot;].(string)</div><div class="line">    place := Place&#123;City:city, Country:country&#125;</div><div class="line">    places = append(places, place)</div><div class="line">    return places</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后调用和输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">func main() &#123;</div><div class="line">    personsA, placesA := decode([]byte(jsonString))</div><div class="line">    fmt.Printf(&quot;%+v\n&quot;, personsA)</div><div class="line">    fmt.Printf(&quot;%+v\n&quot;, placesA)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/usr/local/go/bin/go run /Users/ghost/Rsj217/go/src/demo/main.go</div><div class="line">[&#123;Name:Alice Age:37&#125; &#123;Name:Bob Age:36&#125;]</div><div class="line">[&#123;City:Ipoh Country:Malaysia&#125; &#123;City:Northampton Country:England&#125;]</div></pre></td></tr></table></figure>
<h4 id="混合结构"><a href="#混合结构" class="headerlink" title="混合结构"></a>混合结构</h4><p>混合结构很好理解，如同我们前面解析username为 email和phone两种情况，就在结构中定义好这两种结构即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">type Mixed struct &#123;</div><div class="line">    Name    string `json:&quot;name&quot;`</div><div class="line">    Age     int    `json:&quot;age&quot;`</div><div class="line">    city    string `json:&quot;city&quot;`</div><div class="line">    Country string `json:&quot;country&quot;`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>混合结构的思路很简单，借助golang会初始化没有匹配的json和抛弃没有匹配的json，给特定的字段赋值。比如每一个item都具有四个字段，只不过有的会匹配person的json数据，有的则是匹配place。没有匹配的字段则是零值。接下来在根据item的具体情况，分别赋值到对于的Person或Place结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">func decode(jsonStr []byte) (persons []Person, places []Place) &#123;</div><div class="line">    var data map[string][]Mixed</div><div class="line">    err := json.Unmarshal(jsonStr, &amp;data)</div><div class="line">    if err != nil &#123;</div><div class="line">        fmt.Println(err)</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    fmt.Printf(&quot;%+v\n&quot;, data[&quot;things&quot;])</div><div class="line">    for i := range data[&quot;things&quot;] &#123;</div><div class="line">        item := data[&quot;things&quot;][i]</div><div class="line">        if item.Name != &quot;&quot; &#123;</div><div class="line">            persons = append(persons, Person&#123;Name: item.Name, Age: item.Age&#125;)</div><div class="line">        &#125; else &#123;</div><div class="line">            places = append(places, Place&#123;City: item.city, Country: item.Country&#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>混合结构的解析方式也很不错。思路还是借助了解析json中抛弃不要的字段，借助零值处理。</p>
<h4 id="json-RawMessage"><a href="#json-RawMessage" class="headerlink" title="json.RawMessage"></a>json.RawMessage</h4><p>json.RawMessage非常有用，延迟解析也可以使用这个样例。我们已经介绍过类似的技巧，下面就贴代码了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">func addPerson(item json.RawMessage, persons []Person)([]Person)&#123;</div><div class="line">    person := Person&#123;&#125;</div><div class="line">    if err := json.Unmarshal(item, &amp;person); err != nil&#123;</div><div class="line">        fmt.Println(err)</div><div class="line">    &#125;else&#123;</div><div class="line">        if person != *new(Person)&#123;</div><div class="line">            persons = append(persons, person)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return persons</div><div class="line">&#125;</div><div class="line"></div><div class="line">func addPlace(item json.RawMessage, places []Place)([]Place)&#123;</div><div class="line">    place :=Place&#123;&#125;</div><div class="line">    if err := json.Unmarshal(item, &amp;place); err != nil&#123;</div><div class="line">        fmt.Println(err)</div><div class="line">    &#125;else&#123;</div><div class="line">        if place != *new(Place)&#123;</div><div class="line">            places = append(places, place)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return places</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">func decode(jsonStr []byte)(persons []Person, places []Place)&#123;</div><div class="line">    var data map[string][]json.RawMessage</div><div class="line">    err := json.Unmarshal(jsonStr, &amp;data)</div><div class="line">    if err != nil&#123;</div><div class="line">        fmt.Println(err)</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for _, item := range data[&quot;things&quot;]&#123;</div><div class="line">        persons = addPerson(item, persons)</div><div class="line">        places = addPlace(item, places)</div><div class="line">    &#125;</div><div class="line">    return</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把things的item数组解析成一个json.RawMessage，然后再定义其他结构逐步解析。上述这些例子其实在真实的开发环境下，应该尽量避免。像person或是place这样的数据，可以定义两个数组分别存储他们，这样就方便很多。不管怎么样，通过这个略傻的例子，我们也知道了如何解析json数据。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于golang解析json的介绍基本就这么多。想要解析越简单，就需要定义越明确的map结构。面对无法确定的数据结构或类型，再动态解析方面可以借助接口与断言的方式解析，也可以使用json.RawMessage延迟解析。具体使用情况，还得考虑实际的需求和应用场景。</p>
<p>总而言之，使用json作为现在api的数据通信方式已经很普遍了。我们从启动服务，构造请求，解析请求，渲染模板，持久化到现在的json解析，涉及一个request-response生命周期的介绍完整了。</p>
<p>接下来自然就是利用这些，构建一个简单的web应用。当然，我们可能根据需要，构建不同的应用。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/wechatpay.jpeg" alt="rsj217 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/golang/" rel="tag">#golang</a>
          
            <a href="/tags/mysql/" rel="tag">#mysql</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/01/23/Golang处理JSON（一）--- 编码/" rel="next" title="Golang处理JSON（一）--- 编码">
                <i class="fa fa-chevron-left"></i> Golang处理JSON（一）--- 编码
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/14/Golang 微框架 Gin 简介/" rel="prev" title="Golang 微框架 Gin 简介">
                Golang 微框架 Gin 简介 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/avatar.jpg"
               alt="rsj217" />
          <p class="site-author-name" itemprop="name">rsj217</p>
          <p class="site-description motion-element" itemprop="description">人世间的Blog</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">77</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/rsj217" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/rsj217" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义结构"><span class="nav-number">1.</span> <span class="nav-text">定义结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#string-tag"><span class="nav-number">1.1.</span> <span class="nav-text">string tag</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tag"><span class="nav-number">1.2.</span> <span class="nav-text">- tag</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态解析"><span class="nav-number">2.</span> <span class="nav-text">动态解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Decode"><span class="nav-number">2.1.</span> <span class="nav-text">Decode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口"><span class="nav-number">2.2.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#延迟解析"><span class="nav-number">2.3.</span> <span class="nav-text">延迟解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不定字段解析"><span class="nav-number">3.</span> <span class="nav-text">不定字段解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#接口配合断言"><span class="nav-number">3.1.</span> <span class="nav-text">接口配合断言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#混合结构"><span class="nav-number">3.2.</span> <span class="nav-text">混合结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#json-RawMessage"><span class="nav-number">3.3.</span> <span class="nav-text">json.RawMessage</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rsj217</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

  


</body>
</html>
